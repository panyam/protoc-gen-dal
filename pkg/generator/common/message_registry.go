// Copyright 2025 Sri Panyam
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package common

import (
	"fmt"
	"log"
	"sort"

	"github.com/panyam/protoc-gen-dal/pkg/collector"
	"google.golang.org/protobuf/compiler/protogen"
)

// MessageRegistry tracks mappings between source proto messages and their target equivalents.
//
// When generating database structs, we often need to find the target type for a message field.
// For example, if api.Blog has an "Author author" field, we need to find AuthorGORM or AuthorDatastore.
//
// The registry also handles auto-generation of missing types:
// - If a message field references api.Author but no AuthorGORM exists, auto-generate one
// - Ensures package-wide uniqueness (one AuthorGORM even if used in multiple tables)
type MessageRegistry struct {
	// sourceToTarget maps source message full name → target message
	// Example: "api.Author" → AuthorGorm message
	sourceToTarget map[string]*protogen.Message

	// targetStructNames maps target message → generated struct name
	// Example: AuthorGorm message → "AuthorGORM"
	// This uses the target-specific naming function (buildStructName)
	targetStructNames map[*protogen.Message]string

	// autoGenerated tracks which messages were auto-generated
	// This helps with debugging and prevents duplicate generation
	autoGenerated map[string]bool

	// structNameFunc is the target-specific function to convert message names
	// GORM: "AuthorGorm" → "AuthorGORM"
	// Datastore: "AuthorDatastore" → "AuthorDatastore"
	structNameFunc StructNameFunc
}

// NewMessageRegistry creates a registry from collected messages.
//
// Parameters:
//   - messages: Collected messages from the target (GORM, Datastore, etc.)
//   - structNameFunc: Target-specific naming function
//
// Returns:
//   - Registry populated with source → target mappings
func NewMessageRegistry(messages []*collector.MessageInfo, structNameFunc StructNameFunc) *MessageRegistry {
	reg := &MessageRegistry{
		sourceToTarget:    make(map[string]*protogen.Message),
		targetStructNames: make(map[*protogen.Message]string),
		autoGenerated:     make(map[string]bool),
		structNameFunc:    structNameFunc,
	}

	// Build mappings for explicitly defined messages
	for _, msg := range messages {
		if msg.SourceMessage != nil {
			sourceKey := string(msg.SourceMessage.Desc.FullName())
			reg.sourceToTarget[sourceKey] = msg.TargetMessage
			reg.targetStructNames[msg.TargetMessage] = structNameFunc(msg.TargetMessage)
		}
	}

	return reg
}

// LookupTargetMessage finds the target message for a given source message.
//
// This is used when encountering a message field to determine what type to use.
// For example, if we see "Author author" in api.Blog, we look up api.Author
// to find AuthorGorm (if it exists).
//
// Parameters:
//   - sourceMsg: The source proto message (e.g., api.Author)
//
// Returns:
//   - Target message if found (e.g., AuthorGorm), nil otherwise
func (r *MessageRegistry) LookupTargetMessage(sourceMsg *protogen.Message) *protogen.Message {
	if sourceMsg == nil {
		return nil
	}
	sourceKey := string(sourceMsg.Desc.FullName())
	return r.sourceToTarget[sourceKey]
}

// GetStructName returns the generated struct name for a target message.
//
// Parameters:
//   - targetMsg: The target message (e.g., AuthorGorm)
//
// Returns:
//   - Struct name (e.g., "AuthorGORM"), empty string if not found
func (r *MessageRegistry) GetStructName(targetMsg *protogen.Message) string {
	if targetMsg == nil {
		return ""
	}
	return r.targetStructNames[targetMsg]
}

// ValidateMissingTypes scans all messages and reports errors for any source message types
// that are referenced but don't have explicit target definitions.
//
// This enforces that users must explicitly define all message types they want to use.
// No auto-generation - user control and clarity.
//
// Parameters:
//   - messages: Collected messages to validate
//
// Returns:
//   - error if any referenced types are missing from the registry
func (r *MessageRegistry) ValidateMissingTypes(messages []*collector.MessageInfo) error {
	// Track which source messages are referenced in fields
	referencedSources := make(map[string]*protogen.Message)

	// Single pass: scan all messages to find referenced types
	for _, msg := range messages {
		// Merge source and target fields
		mergedFields, err := MergeSourceFields(msg.SourceMessage, msg.TargetMessage)
		if err != nil {
			return fmt.Errorf("failed to merge fields for %s: %w", msg.TargetMessage.Desc.Name(), err)
		}

		// Scan for message-type fields
		for _, field := range mergedFields {
			r.collectReferencedMessage(field, referencedSources)
		}
	}

	// Check for missing types (referenced but not in registry)
	var missingTypes []string
	for sourceKey, sourceMsg := range referencedSources {
		// Skip if already in registry as a source type
		if r.LookupTargetMessage(sourceMsg) != nil {
			continue
		}

		// Skip if this IS a target type (appears in targetStructNames)
		// This prevents trying to generate GORM types for GORM types
		if _, isTargetType := r.targetStructNames[sourceMsg]; isTargetType {
			continue
		}

		// Skip well-known types
		if _, isWellKnown := GetWellKnownTypeMapping(sourceMsg); isWellKnown {
			continue
		}

		// Missing type - user needs to define it
		missingTypes = append(missingTypes, sourceKey)
	}

	if len(missingTypes) > 0 {
		// Sort for deterministic error messages
		sort.Strings(missingTypes)
		log.Printf("ERROR: The following message types are referenced but not defined:")
		for _, sourceKey := range missingTypes {
			log.Printf("  - %s (define a message with 'source: \"%s\"')", sourceKey, sourceKey)
		}
		return fmt.Errorf("missing target definitions for %d message type(s): %v", len(missingTypes), missingTypes)
	}

	return nil
}

// collectReferencedMessage recursively collects all message types referenced by a field.
func (r *MessageRegistry) collectReferencedMessage(field *protogen.Field, referencedSources map[string]*protogen.Message) {
	if field.Desc.Kind().String() != "message" {
		return
	}

	// Handle map fields - check the value type
	if field.Desc.IsMap() {
		mapEntry := field.Message
		valueField := mapEntry.Fields[1] // value is at index 1
		if valueField.Desc.Kind().String() == "message" {
			sourceKey := string(valueField.Message.Desc.FullName())
			referencedSources[sourceKey] = valueField.Message
		}
		return
	}

	// Handle repeated and regular message fields
	if field.Message != nil {
		sourceKey := string(field.Message.Desc.FullName())
		referencedSources[sourceKey] = field.Message
	}
}
