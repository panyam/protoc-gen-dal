// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package {{ .PackageName }}

{{ if .Imports }}
import (
{{- range .Imports }}
	{{ if .Alias }}{{ .Alias }} {{ end }}"{{ .Path }}"
{{- end }}
)
{{ end }}

{{ range .DALs }}
{{ if .HasCompositePK }}
// {{ .PKStructName }} represents the composite primary key for {{ $.EntityPrefix }}{{ .StructName }}
type {{ .PKStructName }} struct {
{{- range .PrimaryKeys }}
	{{ .Name }} {{ .Type }}
{{- end }}
}
{{ end }}

// {{ .DALTypeName }} provides database access helper methods for {{ $.EntityPrefix }}{{ .StructName }}.
type {{ .DALTypeName }} struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *{{ $.EntityPrefix }}{{ .StructName }}) error
}

// New{{ .DALTypeName }} creates a new {{ .DALTypeName }} instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func New{{ .DALTypeName }}(tableName string) *{{ .DALTypeName }} {
	return &{{ .DALTypeName }}{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *{{ .DALTypeName }}) db(db *{{ $.GormAlias }}.DB) *{{ $.GormAlias }}.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new {{ $.EntityPrefix }}{{ .StructName }} record.
// Returns an error if the record already exists.
func (d *{{ .DALTypeName }}) Create(ctx context.Context, db *{{ $.GormAlias }}.DB, obj *{{ $.EntityPrefix }}{{ .StructName }}) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing {{ $.EntityPrefix }}{{ .StructName }} record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//   dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *{{ .DALTypeName }}) Update(ctx context.Context, db *{{ $.GormAlias }}.DB, obj *{{ $.EntityPrefix }}{{ .StructName }}) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return {{ $.GormAlias }}.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a {{ $.EntityPrefix }}{{ .StructName }} record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//   dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *{{ .DALTypeName }}) Save(ctx context.Context, db *{{ $.GormAlias }}.DB, obj *{{ $.EntityPrefix }}{{ .StructName }}) error {
	// Validate primary key(s)
{{- range .PrimaryKeys }}
	if obj.{{ .Name }} == {{ zeroValue .Type }} {
		return errors.New("primary key '{{ .Name }}' cannot be empty")
	}
{{- end }}

	// Check if record exists by trying to fetch it
	var existing {{ $.EntityPrefix }}{{ .StructName }}
	err := d.db(db).First(&existing, {{ range $i, $pk := .PrimaryKeys }}{{if $i}}, {{end}}"{{ snakeCase $pk.Name }} = ?"{{ end }}{{ range .PrimaryKeys }}, obj.{{ .Name }}{{ end }}).Error

	if err != nil {
		if errors.Is(err, {{ $.GormAlias }}.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a {{ $.EntityPrefix }}{{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
// Returns (nil, nil) if the record is not found (not an error).
func (d *{{ .DALTypeName }}) Get(ctx context.Context, db *{{ $.GormAlias }}.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) (*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var out {{ $.EntityPrefix }}{{ .StructName }}
{{ if .HasCompositePK }}	err := d.db(db).First(&out, {{ buildWhereClause .PrimaryKeys }}).Error
{{ else }}	err := d.db(db).First(&out, "{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Error
{{ end }}	if err != nil {
		if errors.Is(err, {{ $.GormAlias }}.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a {{ $.EntityPrefix }}{{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
func (d *{{ .DALTypeName }}) Delete(ctx context.Context, db *{{ $.GormAlias }}.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) error {
{{ if .HasCompositePK }}	return d.db(db).Where({{ buildWhereClause .PrimaryKeys }}).Delete(&{{ $.EntityPrefix }}{{ .StructName }}{}).Error
{{ else }}	return d.db(db).Where("{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Delete(&{{ $.EntityPrefix }}{{ .StructName }}{}).Error
{{ end }}}

// List retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *{{ .DALTypeName }}) List(ctx context.Context, query *{{ $.GormAlias }}.DB) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} records by primary key{{ if .HasCompositePK }}s{{ end }}.
// Results are returned in the order provided by the database (not necessarily the input order).
{{ if .HasCompositePK }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *{{ $.GormAlias }}.DB, keys []{{ .PKStructName }}) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len(keys) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	// Build OR query for each key combination
	query := d.db(db).Where("1 = 0") // Start with false condition
	for _, key := range keys {
		query = query.Or({{ buildWhereClauseFromStruct .PrimaryKeys "key" }})
	}

	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := query.Find(&out).Error
	return out, err
}
{{ else }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *{{ $.GormAlias }}.DB, {{ toLower (index .PrimaryKeys 0).Name }}s []{{ (index .PrimaryKeys 0).Type }}) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len({{ toLower (index .PrimaryKeys 0).Name }}s) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := d.db(db).Where("{{ (index .PrimaryKeys 0).ColumnName }} IN ?", {{ toLower (index .PrimaryKeys 0).Name }}s).Find(&out).Error
	return out, err
}
{{ end }}
{{ end }}
