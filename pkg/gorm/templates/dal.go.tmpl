// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package {{ .PackageName }}

{{ if .Imports }}
import (
{{- range .Imports }}
	{{ if .Alias }}{{ .Alias }} {{ end }}"{{ .Path }}"
{{- end }}
)
{{ end }}

{{ range .DALs }}
{{ if .HasCompositePK }}
// {{ .PKStructName }} represents the composite primary key for {{ $.EntityPrefix }}{{ .StructName }}
type {{ .PKStructName }} struct {
{{- range .PrimaryKeys }}
	{{ .Name }} {{ .Type }}
{{- end }}
}
{{ end }}

// {{ .DALTypeName }} provides database access helper methods for {{ $.EntityPrefix }}{{ .StructName }}.
type {{ .DALTypeName }} struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *{{ $.EntityPrefix }}{{ .StructName }}) error
}

// Save creates or updates a {{ $.EntityPrefix }}{{ .StructName }} record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *{{ .DALTypeName }}) Save(ctx context.Context, db *{{ $.GormAlias }}.DB, obj *{{ $.EntityPrefix }}{{ .StructName }}) error {
	// Validate primary key(s)
{{- range .PrimaryKeys }}
	if obj.{{ .Name }} == {{ zeroValue .Type }} {
		return errors.New("primary key '{{ .Name }}' cannot be empty")
	}
{{- end }}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a {{ $.EntityPrefix }}{{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
// Returns (nil, nil) if the record is not found (not an error).
func (d *{{ .DALTypeName }}) Get(ctx context.Context, db *{{ $.GormAlias }}.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) (*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var out {{ $.EntityPrefix }}{{ .StructName }}
{{ if .HasCompositePK }}	err := db.First(&out, {{ buildWhereClause .PrimaryKeys }}).Error
{{ else }}	err := db.First(&out, "{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Error
{{ end }}	if err != nil {
		if errors.Is(err, {{ $.GormAlias }}.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a {{ $.EntityPrefix }}{{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
func (d *{{ .DALTypeName }}) Delete(ctx context.Context, db *{{ $.GormAlias }}.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) error {
{{ if .HasCompositePK }}	return db.Where({{ buildWhereClause .PrimaryKeys }}).Delete(&{{ $.EntityPrefix }}{{ .StructName }}{}).Error
{{ else }}	return db.Where("{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Delete(&{{ $.EntityPrefix }}{{ .StructName }}{}).Error
{{ end }}}

// List retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *{{ .DALTypeName }}) List(ctx context.Context, query *{{ $.GormAlias }}.DB) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} records by primary key{{ if .HasCompositePK }}s{{ end }}.
// Results are returned in the order provided by the database (not necessarily the input order).
{{ if .HasCompositePK }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *{{ $.GormAlias }}.DB, keys []{{ .PKStructName }}) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len(keys) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	// Build OR query for each key combination
	query := db.Where("1 = 0") // Start with false condition
	for _, key := range keys {
		query = query.Or({{ buildWhereClauseFromStruct .PrimaryKeys "key" }})
	}

	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := query.Find(&out).Error
	return out, err
}
{{ else }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *{{ $.GormAlias }}.DB, {{ toLower (index .PrimaryKeys 0).Name }}s []{{ (index .PrimaryKeys 0).Type }}) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len({{ toLower (index .PrimaryKeys 0).Name }}s) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	var out []*{{ $.EntityPrefix }}{{ .StructName }}
	err := db.Where("{{ (index .PrimaryKeys 0).ColumnName }} IN ?", {{ toLower (index .PrimaryKeys 0).Name }}s).Find(&out).Error
	return out, err
}
{{ end }}
{{ end }}
