// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"errors"

	"gorm.io/gorm"
)

{{ range .DALs }}
{{ if .HasCompositePK }}
// {{ .PKStructName }} represents the composite primary key for {{ .StructName }}
type {{ .PKStructName }} struct {
{{- range .PrimaryKeys }}
	{{ .Name }} {{ .Type }}
{{- end }}
}
{{ end }}

// {{ .DALTypeName }} provides database access helper methods for {{ .StructName }}.
type {{ .DALTypeName }} struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *{{ .StructName }}) error
}

// Save creates or updates a {{ .StructName }} record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *{{ .DALTypeName }}) Save(ctx context.Context, db *gorm.DB, obj *{{ .StructName }}) error {
	// Validate primary key(s)
{{- range .PrimaryKeys }}
	if obj.{{ .Name }} == {{ zeroValue .Type }} {
		return errors.New("primary key '{{ .Name }}' cannot be empty")
	}
{{- end }}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a {{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
// Returns (nil, nil) if the record is not found (not an error).
func (d *{{ .DALTypeName }}) Get(ctx context.Context, db *gorm.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) (*{{ .StructName }}, error) {
	var out {{ .StructName }}
{{ if .HasCompositePK }}	err := db.First(&out, {{ buildWhereClause .PrimaryKeys }}).Error
{{ else }}	err := db.First(&out, "{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Error
{{ end }}	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a {{ .StructName }} record by primary key{{ if .HasCompositePK }}s{{ end }}.
func (d *{{ .DALTypeName }}) Delete(ctx context.Context, db *gorm.DB{{ range .PrimaryKeys }}, {{ toLower .Name }} {{ .Type }}{{ end }}) error {
{{ if .HasCompositePK }}	return db.Where({{ buildWhereClause .PrimaryKeys }}).Delete(&{{ .StructName }}{}).Error
{{ else }}	return db.Where("{{ (index .PrimaryKeys 0).ColumnName }} = ?", {{ toLower (index .PrimaryKeys 0).Name }}).Delete(&{{ .StructName }}{}).Error
{{ end }}}

// List retrieves multiple {{ .StructName }} records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *{{ .DALTypeName }}) List(ctx context.Context, query *gorm.DB) ([]*{{ .StructName }}, error) {
	var out []*{{ .StructName }}
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple {{ .StructName }} records by primary key{{ if .HasCompositePK }}s{{ end }}.
// Results are returned in the order provided by the database (not necessarily the input order).
{{ if .HasCompositePK }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *gorm.DB, keys []{{ .PKStructName }}) ([]*{{ .StructName }}, error) {
	if len(keys) == 0 {
		return []*{{ .StructName }}{}, nil
	}

	// Build OR query for each key combination
	query := db.Where("1 = 0") // Start with false condition
	for _, key := range keys {
		query = query.Or({{ buildWhereClauseFromStruct .PrimaryKeys "key" }})
	}

	var out []*{{ .StructName }}
	err := query.Find(&out).Error
	return out, err
}
{{ else }}func (d *{{ .DALTypeName }}) BatchGet(ctx context.Context, db *gorm.DB, {{ toLower (index .PrimaryKeys 0).Name }}s []{{ (index .PrimaryKeys 0).Type }}) ([]*{{ .StructName }}, error) {
	if len({{ toLower (index .PrimaryKeys 0).Name }}s) == 0 {
		return []*{{ .StructName }}{}, nil
	}

	var out []*{{ .StructName }}
	err := db.Where("{{ (index .PrimaryKeys 0).ColumnName }} IN ?", {{ toLower (index .PrimaryKeys 0).Name }}s).Find(&out).Error
	return out, err
}
{{ end }}
{{ end }}
