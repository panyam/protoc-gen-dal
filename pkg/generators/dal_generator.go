// Copyright 2025 Sri Panyam
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package generators

import (
	"fmt"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/proto"

	"github.com/panyam/protoc-gen-dal/pkg/builders"
	"github.com/panyam/protoc-gen-dal/pkg/filters"
	dalv1 "github.com/panyam/protoc-gen-dal/protos/gen/dal/v1"
)

// DALGenerator generates Data Access Layer converters for protobuf messages
type DALGenerator struct {
	plugin *protogen.Plugin
}

// NewDALGenerator creates a new DALGenerator
func NewDALGenerator(plugin *protogen.Plugin) *DALGenerator {
	return &DALGenerator{
		plugin: plugin,
	}
}

// ValidateConfig validates the generation configuration
func (g *DALGenerator) ValidateConfig(config *builders.GenerationConfig) error {
	// Validate target
	validTargets := map[string]bool{
		"raw":       true,
		"gorm":      true,
		"datastore": true,
		"firestore": true,
	}
	if !validTargets[config.Target] {
		return fmt.Errorf("unsupported target: %s (valid: raw, gorm, datastore, firestore)", config.Target)
	}

	// Validate datastore types (only needed for raw/gorm targets)
	if config.Target == "raw" || config.Target == "gorm" {
		if config.Datastores == "" {
			return fmt.Errorf("datastores configuration is required for target '%s'", config.Target)
		}

		datastores := strings.Split(config.Datastores, ",")
		validDatastores := map[string]bool{
			"postgres":  true,
			"mysql":     true,
			"sqlite":    true,
			"mongodb":   true,
			"redis":     true,
			"dynamodb":  true,
			"firestore": true,
		}

		for _, ds := range datastores {
			ds = strings.TrimSpace(ds)
			if !validDatastores[ds] {
				return fmt.Errorf("unsupported datastore: %s (valid: postgres, mysql, sqlite, mongodb, redis, dynamodb, firestore)", ds)
			}
		}
	}

	return nil
}

// Generate generates DAL converter code based on the configuration
func (g *DALGenerator) Generate(config *builders.GenerationConfig, filterCriteria *filters.FilterCriteria) error {
	// Parse datastores
	datastores := parseDatastores(config.Datastores)

	// Process each proto file
	for _, file := range g.plugin.Files {
		if !file.Generate {
			continue
		}

		// Collect messages that should have converters generated
		var messages []*protogen.Message
		for _, message := range file.Messages {
			// Skip if message has skip_dal annotation
			if g.shouldSkipMessage(message) {
				continue
			}
			if filterCriteria.ShouldIncludeMessage(string(message.Desc.Name())) {
				messages = append(messages, message)
			}
		}

		if len(messages) == 0 {
			continue
		}

		// Generate converters for each datastore
		for _, datastore := range datastores {
			if err := g.generateConvertersForDatastore(file, messages, datastore, config); err != nil {
				return fmt.Errorf("failed to generate %s converters: %w", datastore, err)
			}
		}
	}

	return nil
}

// generateConvertersForDatastore generates converter code for a specific datastore
func (g *DALGenerator) generateConvertersForDatastore(file *protogen.File, messages []*protogen.Message, datastore string, config *builders.GenerationConfig) error {
	// Determine output filename
	outputFilename := fmt.Sprintf("%s/%s_%s.go", config.DALExportPath, file.GeneratedFilenamePrefix, datastore)

	// Create output file
	genFile := g.plugin.NewGeneratedFile(outputFilename, file.GoImportPath)

	// Generate file header
	g.generateFileHeader(genFile, file, config.PackageName)

	// Generate imports
	g.generateImports(genFile, file, datastore)

	// Generate converter functions for each message
	for _, message := range messages {
		switch datastore {
		case "postgres", "mysql", "sqlite":
			g.generateSQLConverters(genFile, message, datastore)
		case "mongodb":
			g.generateMongoDBConverters(genFile, message)
		case "redis":
			g.generateRedisConverters(genFile, message)
		case "dynamodb":
			g.generateDynamoDBConverters(genFile, message)
		}
	}

	return nil
}

// generateFileHeader generates the file header
func (g *DALGenerator) generateFileHeader(genFile *protogen.GeneratedFile, file *protogen.File, packageName string) {
	genFile.P("// Code generated by protoc-gen-dal. DO NOT EDIT.")
	genFile.P("// source: ", file.Desc.Path())
	genFile.P()
	genFile.P("package ", packageName)
	genFile.P()
}

// generateImports generates import statements
func (g *DALGenerator) generateImports(genFile *protogen.GeneratedFile, file *protogen.File, datastore string) {
	genFile.P("import (")

	// Always import the proto package
	genFile.P("\t", genFile.QualifiedGoIdent(protogen.GoIdent{
		GoName:       "",
		GoImportPath: file.GoImportPath,
	}))

	// Datastore-specific imports
	switch datastore {
	case "postgres", "mysql", "sqlite":
		genFile.P("\t\"database/sql\"")
	case "mongodb":
		genFile.P("\t\"go.mongodb.org/mongo-driver/bson\"")
	case "redis":
		genFile.P("\t\"github.com/go-redis/redis/v8\"")
	case "dynamodb":
		genFile.P("\t\"github.com/aws/aws-sdk-go/service/dynamodb\"")
		genFile.P("\t\"github.com/aws/aws-sdk-go/service/dynamodb/dynamodbattribute\"")
	}

	genFile.P(")")
	genFile.P()
}

// generateSQLConverters generates SQL converter functions
func (g *DALGenerator) generateSQLConverters(genFile *protogen.GeneratedFile, message *protogen.Message, dbType string) {
	messageName := string(message.Desc.Name())
	messageType := genFile.QualifiedGoIdent(message.GoIdent)

	// Get table name from annotation or use default
	tableName := g.getTableName(message)

	// Generate ToRow converter
	genFile.P("// ", messageName, "To", capitalize(dbType), "Row converts a ", messageName, " to SQL row values")
	genFile.P("// Table: ", tableName)
	genFile.P("func ", messageName, "To", capitalize(dbType), "Row(msg *", messageType, ") (columns []string, values []any) {")
	genFile.P("\tcolumns = []string{")
	for _, field := range message.Fields {
		if g.shouldSkipField(field) {
			continue
		}
		colName := g.getColumnName(field)
		genFile.P("\t\t\"", colName, "\",")
	}
	genFile.P("\t}")
	genFile.P()
	genFile.P("\tvalues = []any{")
	for _, field := range message.Fields {
		if g.shouldSkipField(field) {
			continue
		}
		genFile.P("\t\tmsg.", field.GoName, ",")
	}
	genFile.P("\t}")
	genFile.P()
	genFile.P("\treturn columns, values")
	genFile.P("}")
	genFile.P()

	// Generate FromRow converter
	genFile.P("// ", messageName, "From", capitalize(dbType), "Row converts SQL row to a ", messageName)
	genFile.P("// Table: ", tableName)
	genFile.P("func ", messageName, "From", capitalize(dbType), "Row(row *sql.Row) (*", messageType, ", error) {")
	genFile.P("\tmsg := &", messageType, "{}")
	genFile.P("\terr := row.Scan(")
	for _, field := range message.Fields {
		if g.shouldSkipField(field) {
			continue
		}
		genFile.P("\t\t&msg.", field.GoName, ",")
	}
	genFile.P("\t)")
	genFile.P("\tif err != nil {")
	genFile.P("\t\treturn nil, err")
	genFile.P("\t}")
	genFile.P("\treturn msg, nil")
	genFile.P("}")
	genFile.P()

	// Generate FromRows converter for multiple rows
	genFile.P("// ", messageName, "From", capitalize(dbType), "Rows converts SQL rows to a ", messageName)
	genFile.P("// Table: ", tableName)
	genFile.P("func ", messageName, "From", capitalize(dbType), "Rows(rows *sql.Rows) (*", messageType, ", error) {")
	genFile.P("\tmsg := &", messageType, "{}")
	genFile.P("\terr := rows.Scan(")
	for _, field := range message.Fields {
		if g.shouldSkipField(field) {
			continue
		}
		genFile.P("\t\t&msg.", field.GoName, ",")
	}
	genFile.P("\t)")
	genFile.P("\tif err != nil {")
	genFile.P("\t\treturn nil, err")
	genFile.P("\t}")
	genFile.P("\treturn msg, nil")
	genFile.P("}")
	genFile.P()
}

// generateMongoDBConverters generates MongoDB converter functions
func (g *DALGenerator) generateMongoDBConverters(genFile *protogen.GeneratedFile, message *protogen.Message) {
	messageName := string(message.Desc.Name())
	messageType := genFile.QualifiedGoIdent(message.GoIdent)

	genFile.P("// ", messageName, "ToBSON converts a ", messageName, " to BSON")
	genFile.P("func ", messageName, "ToBSON(msg *", messageType, ") (bson.M, error) {")
	genFile.P("\tdoc := bson.M{")
	for _, field := range message.Fields {
		fieldName := toLowerCamelCase(field.GoName)
		genFile.P("\t\t\"", fieldName, "\": msg.", field.GoName, ",")
	}
	genFile.P("\t}")
	genFile.P("\treturn doc, nil")
	genFile.P("}")
	genFile.P()

	genFile.P("// ", messageName, "FromBSON converts BSON to a ", messageName)
	genFile.P("func ", messageName, "FromBSON(doc bson.M) (*", messageType, ", error) {")
	genFile.P("\tmsg := &", messageType, "{}")
	genFile.P("\t// TODO: Implement field mapping from BSON document")
	genFile.P("\treturn msg, nil")
	genFile.P("}")
	genFile.P()
}

// generateRedisConverters generates Redis converter functions
func (g *DALGenerator) generateRedisConverters(genFile *protogen.GeneratedFile, message *protogen.Message) {
	messageName := string(message.Desc.Name())
	messageType := genFile.QualifiedGoIdent(message.GoIdent)

	genFile.P("// ", messageName, "ToRedisHash converts a ", messageName, " to Redis hash")
	genFile.P("func ", messageName, "ToRedisHash(msg *", messageType, ") map[string]any {")
	genFile.P("\thash := map[string]any{")
	for _, field := range message.Fields {
		fieldName := toLowerCamelCase(field.GoName)
		genFile.P("\t\t\"", fieldName, "\": msg.", field.GoName, ",")
	}
	genFile.P("\t}")
	genFile.P("\treturn hash")
	genFile.P("}")
	genFile.P()

	genFile.P("// ", messageName, "FromRedisHash converts Redis hash to a ", messageName)
	genFile.P("func ", messageName, "FromRedisHash(hash map[string]string) (*", messageType, ", error) {")
	genFile.P("\tmsg := &", messageType, "{}")
	genFile.P("\t// TODO: Implement field mapping from Redis hash")
	genFile.P("\treturn msg, nil")
	genFile.P("}")
	genFile.P()
}

// generateDynamoDBConverters generates DynamoDB converter functions
func (g *DALGenerator) generateDynamoDBConverters(genFile *protogen.GeneratedFile, message *protogen.Message) {
	messageName := string(message.Desc.Name())
	messageType := genFile.QualifiedGoIdent(message.GoIdent)

	genFile.P("// ", messageName, "ToDynamoDBItem converts a ", messageName, " to DynamoDB item")
	genFile.P("func ", messageName, "ToDynamoDBItem(msg *", messageType, ") (map[string]*dynamodb.AttributeValue, error) {")
	genFile.P("\treturn dynamodbattribute.MarshalMap(msg)")
	genFile.P("}")
	genFile.P()

	genFile.P("// ", messageName, "FromDynamoDBItem converts DynamoDB item to a ", messageName)
	genFile.P("func ", messageName, "FromDynamoDBItem(item map[string]*dynamodb.AttributeValue) (*", messageType, ", error) {")
	genFile.P("\tmsg := &", messageType, "{}")
	genFile.P("\terr := dynamodbattribute.UnmarshalMap(item, msg)")
	genFile.P("\treturn msg, err")
	genFile.P("}")
	genFile.P()
}

// Helper functions

func parseDatastores(datastoresStr string) []string {
	var result []string
	for _, ds := range strings.Split(datastoresStr, ",") {
		ds = strings.TrimSpace(ds)
		if ds != "" {
			result = append(result, ds)
		}
	}
	return result
}

func capitalize(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToUpper(s[:1]) + s[1:]
}

func toSnakeCase(s string) string {
	var result strings.Builder
	for i, r := range s {
		if i > 0 && r >= 'A' && r <= 'Z' {
			result.WriteRune('_')
		}
		result.WriteRune(r)
	}
	return strings.ToLower(result.String())
}

func toLowerCamelCase(s string) string {
	if s == "" {
		return ""
	}
	return strings.ToLower(s[:1]) + s[1:]
}

// getTableName gets the table name from annotation or defaults to snake_case message name
func (g *DALGenerator) getTableName(message *protogen.Message) string {
	opts := message.Desc.Options()
	if opts != nil {
		if v := proto.GetExtension(opts, dalv1.E_Table); v != nil {
			if tableOpts, ok := v.(*dalv1.TableOptions); ok && tableOpts != nil {
				if tableOpts.Name != "" {
					return tableOpts.Name
				}
			}
		}
	}
	// Default to snake_case of message name
	return toSnakeCase(string(message.Desc.Name()))
}

// getColumnName gets the column name from annotation or defaults to snake_case field name
func (g *DALGenerator) getColumnName(field *protogen.Field) string {
	opts := field.Desc.Options()
	if opts != nil {
		if v := proto.GetExtension(opts, dalv1.E_Column); v != nil {
			if colOpts, ok := v.(*dalv1.ColumnOptions); ok && colOpts != nil {
				if colOpts.Name != "" {
					return colOpts.Name
				}
			}
		}
	}
	// Default to snake_case of field name
	return toSnakeCase(field.GoName)
}

// shouldSkipField checks if a field should be skipped from DAL generation
func (g *DALGenerator) shouldSkipField(field *protogen.Field) bool {
	opts := field.Desc.Options()
	if opts != nil {
		if v := proto.GetExtension(opts, dalv1.E_SkipField); v != nil {
			if skipField, ok := v.(bool); ok {
				return skipField
			}
		}
	}
	return false
}

// shouldSkipMessage checks if a message should be skipped from DAL generation
func (g *DALGenerator) shouldSkipMessage(message *protogen.Message) bool {
	opts := message.Desc.Options()
	if opts != nil {
		if v := proto.GetExtension(opts, dalv1.E_SkipDal); v != nil {
			if skipDal, ok := v.(bool); ok {
				return skipDal
			}
		}
	}
	return false
}
