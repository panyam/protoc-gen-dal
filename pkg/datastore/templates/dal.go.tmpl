// Code generated by protoc-gen-dal-datastore. DO NOT EDIT.
package {{ .PackageName }}

{{ if .Imports }}
import (
{{- range .Imports }}
	{{ if .Alias }}{{ .Alias }} {{ end }}"{{ .Path }}"
{{- end }}
)
{{ end }}

{{ range .DALs }}
// {{ .DALTypeName }} provides database access helper methods for {{ $.EntityPrefix }}{{ .StructName }}.
type {{ .DALTypeName }} struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *{{ $.EntityPrefix }}{{ .StructName }}) error
}

// New{{ .DALTypeName }} creates a new {{ .DALTypeName }} instance.
// If kind is empty, operations will use the struct's Kind() method.
func New{{ .DALTypeName }}(kind string) *{{ .DALTypeName }} {
	return &{{ .DALTypeName }}{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *{{ .DALTypeName }}) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity {{ $.EntityPrefix }}{{ .StructName }}
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *{{ .DALTypeName }}) newKey(id string) *{{ $.DatastoreLib }}.Key {
	key := {{ $.DatastoreLib }}.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *{{ .DALTypeName }}) newIncompleteKey() *{{ $.DatastoreLib }}.Key {
	key := {{ $.DatastoreLib }}.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a {{ $.EntityPrefix }}{{ .StructName }} entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *{{ .DALTypeName }}) Put(ctx context.Context, client *{{ $.DatastoreLib }}.Client, obj *{{ $.EntityPrefix }}{{ .StructName }}) (*{{ $.DatastoreLib }}.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *{{ $.DatastoreLib }}.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
{{- if .HasStringID }}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
{{- end }}
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a {{ $.EntityPrefix }}{{ .StructName }} entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *{{ .DALTypeName }}) Get(ctx context.Context, client *{{ $.DatastoreLib }}.Client, key *{{ $.DatastoreLib }}.Key) (*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var entity {{ $.EntityPrefix }}{{ .StructName }}
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == {{ $.DatastoreLib }}.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a {{ $.EntityPrefix }}{{ .StructName }} entity by key.
func (d *{{ .DALTypeName }}) Delete(ctx context.Context, client *{{ $.DatastoreLib }}.Client, key *{{ $.DatastoreLib }}.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *{{ .DALTypeName }}) GetMulti(ctx context.Context, client *{{ $.DatastoreLib }}.Client, keys []*{{ $.DatastoreLib }}.Key) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len(keys) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	entities := make([]{{ $.EntityPrefix }}{{ .StructName }}, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.({{ $.DatastoreLib }}.MultiError); ok {
			result := make([]*{{ $.EntityPrefix }}{{ .StructName }}, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != {{ $.DatastoreLib }}.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*{{ $.EntityPrefix }}{{ .StructName }}, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple {{ $.EntityPrefix }}{{ .StructName }} entities to Datastore.
// Returns the keys used to store the entities.
func (d *{{ .DALTypeName }}) PutMulti(ctx context.Context, client *{{ $.DatastoreLib }}.Client, objs []*{{ $.EntityPrefix }}{{ .StructName }}) ([]*{{ $.DatastoreLib }}.Key, error) {
	if len(objs) == 0 {
		return []*{{ $.DatastoreLib }}.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*{{ $.DatastoreLib }}.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
{{- if .HasStringID }}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
{{- end }}
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple {{ $.EntityPrefix }}{{ .StructName }} entities by keys.
func (d *{{ .DALTypeName }}) DeleteMulti(ctx context.Context, client *{{ $.DatastoreLib }}.Client, keys []*{{ $.DatastoreLib }}.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves {{ $.EntityPrefix }}{{ .StructName }} entities matching the query.
// The caller should create a query using {{ $.DatastoreLib }}.NewQuery(dal.getKind()).
func (d *{{ .DALTypeName }}) Query(ctx context.Context, client *{{ $.DatastoreLib }}.Client, q *{{ $.DatastoreLib }}.Query) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	var entities []*{{ $.EntityPrefix }}{{ .StructName }}
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *{{ .DALTypeName }}) Count(ctx context.Context, client *{{ $.DatastoreLib }}.Client, q *{{ $.DatastoreLib }}.Query) (int, error) {
	return client.Count(ctx, q)
}

{{ if .HasIDField }}
// GetByID retrieves a {{ $.EntityPrefix }}{{ .StructName }} entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *{{ .DALTypeName }}) GetByID(ctx context.Context, client *{{ $.DatastoreLib }}.Client, id {{ .IDFieldType }}) (*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a {{ $.EntityPrefix }}{{ .StructName }} entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *{{ .DALTypeName }}) DeleteByID(ctx context.Context, client *{{ $.DatastoreLib }}.Client, id {{ .IDFieldType }}) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple {{ $.EntityPrefix }}{{ .StructName }} entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *{{ .DALTypeName }}) GetMultiByIDs(ctx context.Context, client *{{ $.DatastoreLib }}.Client, ids []{{ .IDFieldType }}) ([]*{{ $.EntityPrefix }}{{ .StructName }}, error) {
	if len(ids) == 0 {
		return []*{{ $.EntityPrefix }}{{ .StructName }}{}, nil
	}

	keys := make([]*{{ $.DatastoreLib }}.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}
{{ end }}
{{ end }}
