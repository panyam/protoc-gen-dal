// Code generated by protoc-gen-dal-datastore. DO NOT EDIT.
package dal

import (
	"context"

	dslib "cloud.google.com/go/datastore"
	datastore "github.com/panyam/protoc-gen-dal/tests/gen/datastore/datastore"
)

// UserDatastoreDAL provides database access helper methods for datastore.UserDatastore.
type UserDatastoreDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.UserDatastore) error
}

// NewUserDatastoreDAL creates a new UserDatastoreDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewUserDatastoreDAL(kind string) *UserDatastoreDAL {
	return &UserDatastoreDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *UserDatastoreDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.UserDatastore
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *UserDatastoreDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *UserDatastoreDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.UserDatastore entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *UserDatastoreDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.UserDatastore) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.UserDatastore entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *UserDatastoreDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.UserDatastore, error) {
	var entity datastore.UserDatastore
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.UserDatastore entity by key.
func (d *UserDatastoreDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.UserDatastore entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *UserDatastoreDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.UserDatastore, error) {
	if len(keys) == 0 {
		return []*datastore.UserDatastore{}, nil
	}

	entities := make([]datastore.UserDatastore, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.UserDatastore, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.UserDatastore, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.UserDatastore entities to Datastore.
// Returns the keys used to store the entities.
func (d *UserDatastoreDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.UserDatastore) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.UserDatastore entities by keys.
func (d *UserDatastoreDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.UserDatastore entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *UserDatastoreDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.UserDatastore, error) {
	var entities []*datastore.UserDatastore
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *UserDatastoreDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.UserDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *UserDatastoreDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.UserDatastore, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.UserDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *UserDatastoreDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.UserDatastore entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *UserDatastoreDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.UserDatastore, error) {
	if len(ids) == 0 {
		return []*datastore.UserDatastore{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// UserWithNamespaceDAL provides database access helper methods for datastore.UserWithNamespace.
type UserWithNamespaceDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.UserWithNamespace) error
}

// NewUserWithNamespaceDAL creates a new UserWithNamespaceDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewUserWithNamespaceDAL(kind string) *UserWithNamespaceDAL {
	return &UserWithNamespaceDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *UserWithNamespaceDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.UserWithNamespace
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *UserWithNamespaceDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *UserWithNamespaceDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.UserWithNamespace entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *UserWithNamespaceDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.UserWithNamespace) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.UserWithNamespace entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *UserWithNamespaceDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.UserWithNamespace, error) {
	var entity datastore.UserWithNamespace
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.UserWithNamespace entity by key.
func (d *UserWithNamespaceDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.UserWithNamespace entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *UserWithNamespaceDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.UserWithNamespace, error) {
	if len(keys) == 0 {
		return []*datastore.UserWithNamespace{}, nil
	}

	entities := make([]datastore.UserWithNamespace, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.UserWithNamespace, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.UserWithNamespace, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.UserWithNamespace entities to Datastore.
// Returns the keys used to store the entities.
func (d *UserWithNamespaceDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.UserWithNamespace) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.UserWithNamespace entities by keys.
func (d *UserWithNamespaceDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.UserWithNamespace entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *UserWithNamespaceDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.UserWithNamespace, error) {
	var entities []*datastore.UserWithNamespace
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *UserWithNamespaceDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.UserWithNamespace entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *UserWithNamespaceDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.UserWithNamespace, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.UserWithNamespace entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *UserWithNamespaceDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.UserWithNamespace entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *UserWithNamespaceDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.UserWithNamespace, error) {
	if len(ids) == 0 {
		return []*datastore.UserWithNamespace{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// UserWithLargeTextDAL provides database access helper methods for datastore.UserWithLargeText.
type UserWithLargeTextDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.UserWithLargeText) error
}

// NewUserWithLargeTextDAL creates a new UserWithLargeTextDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewUserWithLargeTextDAL(kind string) *UserWithLargeTextDAL {
	return &UserWithLargeTextDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *UserWithLargeTextDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.UserWithLargeText
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *UserWithLargeTextDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *UserWithLargeTextDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.UserWithLargeText entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *UserWithLargeTextDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.UserWithLargeText) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.UserWithLargeText entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *UserWithLargeTextDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.UserWithLargeText, error) {
	var entity datastore.UserWithLargeText
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.UserWithLargeText entity by key.
func (d *UserWithLargeTextDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.UserWithLargeText entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *UserWithLargeTextDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.UserWithLargeText, error) {
	if len(keys) == 0 {
		return []*datastore.UserWithLargeText{}, nil
	}

	entities := make([]datastore.UserWithLargeText, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.UserWithLargeText, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.UserWithLargeText, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.UserWithLargeText entities to Datastore.
// Returns the keys used to store the entities.
func (d *UserWithLargeTextDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.UserWithLargeText) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.UserWithLargeText entities by keys.
func (d *UserWithLargeTextDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.UserWithLargeText entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *UserWithLargeTextDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.UserWithLargeText, error) {
	var entities []*datastore.UserWithLargeText
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *UserWithLargeTextDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.UserWithLargeText entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *UserWithLargeTextDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.UserWithLargeText, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.UserWithLargeText entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *UserWithLargeTextDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.UserWithLargeText entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *UserWithLargeTextDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.UserWithLargeText, error) {
	if len(ids) == 0 {
		return []*datastore.UserWithLargeText{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// UserSimpleDAL provides database access helper methods for datastore.UserSimple.
type UserSimpleDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.UserSimple) error
}

// NewUserSimpleDAL creates a new UserSimpleDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewUserSimpleDAL(kind string) *UserSimpleDAL {
	return &UserSimpleDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *UserSimpleDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.UserSimple
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *UserSimpleDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *UserSimpleDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.UserSimple entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *UserSimpleDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.UserSimple) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.UserSimple entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *UserSimpleDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.UserSimple, error) {
	var entity datastore.UserSimple
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.UserSimple entity by key.
func (d *UserSimpleDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.UserSimple entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *UserSimpleDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.UserSimple, error) {
	if len(keys) == 0 {
		return []*datastore.UserSimple{}, nil
	}

	entities := make([]datastore.UserSimple, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.UserSimple, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.UserSimple, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.UserSimple entities to Datastore.
// Returns the keys used to store the entities.
func (d *UserSimpleDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.UserSimple) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.UserSimple entities by keys.
func (d *UserSimpleDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.UserSimple entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *UserSimpleDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.UserSimple, error) {
	var entities []*datastore.UserSimple
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *UserSimpleDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.UserSimple entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *UserSimpleDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.UserSimple, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.UserSimple entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *UserSimpleDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.UserSimple entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *UserSimpleDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.UserSimple, error) {
	if len(ids) == 0 {
		return []*datastore.UserSimple{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// ProductDatastoreDAL provides database access helper methods for datastore.ProductDatastore.
type ProductDatastoreDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.ProductDatastore) error
}

// NewProductDatastoreDAL creates a new ProductDatastoreDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewProductDatastoreDAL(kind string) *ProductDatastoreDAL {
	return &ProductDatastoreDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *ProductDatastoreDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.ProductDatastore
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *ProductDatastoreDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *ProductDatastoreDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.ProductDatastore entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *ProductDatastoreDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.ProductDatastore) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.ProductDatastore entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *ProductDatastoreDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.ProductDatastore, error) {
	var entity datastore.ProductDatastore
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.ProductDatastore entity by key.
func (d *ProductDatastoreDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.ProductDatastore entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *ProductDatastoreDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.ProductDatastore, error) {
	if len(keys) == 0 {
		return []*datastore.ProductDatastore{}, nil
	}

	entities := make([]datastore.ProductDatastore, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.ProductDatastore, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.ProductDatastore, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.ProductDatastore entities to Datastore.
// Returns the keys used to store the entities.
func (d *ProductDatastoreDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.ProductDatastore) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.ProductDatastore entities by keys.
func (d *ProductDatastoreDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.ProductDatastore entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *ProductDatastoreDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.ProductDatastore, error) {
	var entities []*datastore.ProductDatastore
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *ProductDatastoreDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.ProductDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *ProductDatastoreDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.ProductDatastore, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.ProductDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *ProductDatastoreDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.ProductDatastore entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *ProductDatastoreDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.ProductDatastore, error) {
	if len(ids) == 0 {
		return []*datastore.ProductDatastore{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// LibraryDatastoreDAL provides database access helper methods for datastore.LibraryDatastore.
type LibraryDatastoreDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.LibraryDatastore) error
}

// NewLibraryDatastoreDAL creates a new LibraryDatastoreDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewLibraryDatastoreDAL(kind string) *LibraryDatastoreDAL {
	return &LibraryDatastoreDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *LibraryDatastoreDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.LibraryDatastore
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *LibraryDatastoreDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *LibraryDatastoreDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.LibraryDatastore entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *LibraryDatastoreDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.LibraryDatastore) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.LibraryDatastore entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *LibraryDatastoreDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.LibraryDatastore, error) {
	var entity datastore.LibraryDatastore
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.LibraryDatastore entity by key.
func (d *LibraryDatastoreDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.LibraryDatastore entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *LibraryDatastoreDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.LibraryDatastore, error) {
	if len(keys) == 0 {
		return []*datastore.LibraryDatastore{}, nil
	}

	entities := make([]datastore.LibraryDatastore, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.LibraryDatastore, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.LibraryDatastore, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.LibraryDatastore entities to Datastore.
// Returns the keys used to store the entities.
func (d *LibraryDatastoreDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.LibraryDatastore) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.LibraryDatastore entities by keys.
func (d *LibraryDatastoreDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.LibraryDatastore entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *LibraryDatastoreDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.LibraryDatastore, error) {
	var entities []*datastore.LibraryDatastore
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *LibraryDatastoreDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.LibraryDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *LibraryDatastoreDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.LibraryDatastore, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.LibraryDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *LibraryDatastoreDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.LibraryDatastore entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *LibraryDatastoreDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.LibraryDatastore, error) {
	if len(ids) == 0 {
		return []*datastore.LibraryDatastore{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}

// OrganizationDatastoreDAL provides database access helper methods for datastore.OrganizationDatastore.
type OrganizationDatastoreDAL struct {
	// Kind overrides the Datastore kind for all operations.
	// If empty, uses the struct's Kind() method (if any).
	Kind string

	// Namespace overrides the Datastore namespace for all operations.
	// If empty, uses the default namespace.
	Namespace string

	// WillPut hook is called before Put operations.
	// Return an error to prevent the put.
	WillPut func(context.Context, *datastore.OrganizationDatastore) error
}

// NewOrganizationDatastoreDAL creates a new OrganizationDatastoreDAL instance.
// If kind is empty, operations will use the struct's Kind() method.
func NewOrganizationDatastoreDAL(kind string) *OrganizationDatastoreDAL {
	return &OrganizationDatastoreDAL{Kind: kind}
}

// getKind returns the kind to use for operations.
// Uses the DAL's Kind field if set, otherwise falls back to the struct's Kind() method.
func (d *OrganizationDatastoreDAL) getKind() string {
	if d.Kind != "" {
		return d.Kind
	}
	// Fall back to struct's Kind() method
	var entity datastore.OrganizationDatastore
	return entity.Kind()
}

// newKey creates a new Datastore key for the given ID.
func (d *OrganizationDatastoreDAL) newKey(id string) *dslib.Key {
	key := dslib.NameKey(d.getKind(), id, nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// newIncompleteKey creates a new incomplete Datastore key (for auto-generated IDs).
func (d *OrganizationDatastoreDAL) newIncompleteKey() *dslib.Key {
	key := dslib.IncompleteKey(d.getKind(), nil)
	if d.Namespace != "" {
		key.Namespace = d.Namespace
	}
	return key
}

// Put saves a datastore.OrganizationDatastore entity to Datastore.
// If the entity's Key field is set, uses that key; otherwise creates a key from the ID field.
// Returns the key used to store the entity.
func (d *OrganizationDatastoreDAL) Put(ctx context.Context, client *dslib.Client, obj *datastore.OrganizationDatastore) (*dslib.Key, error) {
	// Call WillPut hook if set
	if d.WillPut != nil {
		if err := d.WillPut(ctx, obj); err != nil {
			return nil, err
		}
	}

	// Determine the key to use
	var key *dslib.Key
	if obj.Key != nil {
		key = obj.Key
		// Apply namespace override if set
		if d.Namespace != "" {
			key.Namespace = d.Namespace
		}
	} else if obj.Id != "" {
		key = d.newKey(obj.Id)
	} else {
		key = d.newIncompleteKey()
	}

	// Put the entity
	resultKey, err := client.Put(ctx, key, obj)
	if err != nil {
		return nil, err
	}

	// Update the entity's key
	obj.Key = resultKey

	return resultKey, nil
}

// Get retrieves a datastore.OrganizationDatastore entity by key.
// Returns (nil, nil) if the entity is not found.
func (d *OrganizationDatastoreDAL) Get(ctx context.Context, client *dslib.Client, key *dslib.Key) (*datastore.OrganizationDatastore, error) {
	var entity datastore.OrganizationDatastore
	err := client.Get(ctx, key, &entity)
	if err != nil {
		if err == dslib.ErrNoSuchEntity {
			return nil, nil
		}
		return nil, err
	}
	entity.Key = key
	return &entity, nil
}

// Delete removes a datastore.OrganizationDatastore entity by key.
func (d *OrganizationDatastoreDAL) Delete(ctx context.Context, client *dslib.Client, key *dslib.Key) error {
	return client.Delete(ctx, key)
}

// GetMulti retrieves multiple datastore.OrganizationDatastore entities by keys.
// Returns entities in the same order as the keys. Missing entities are nil in the result slice.
func (d *OrganizationDatastoreDAL) GetMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) ([]*datastore.OrganizationDatastore, error) {
	if len(keys) == 0 {
		return []*datastore.OrganizationDatastore{}, nil
	}

	entities := make([]datastore.OrganizationDatastore, len(keys))
	err := client.GetMulti(ctx, keys, entities)
	if err != nil {
		// Handle partial errors (some entities not found)
		if multiErr, ok := err.(dslib.MultiError); ok {
			result := make([]*datastore.OrganizationDatastore, len(keys))
			for i, e := range multiErr {
				if e == nil {
					entities[i].Key = keys[i]
					result[i] = &entities[i]
				} else if e != dslib.ErrNoSuchEntity {
					return nil, err // Return on non-NotFound errors
				}
				// nil for not-found entities
			}
			return result, nil
		}
		return nil, err
	}

	// All entities found
	result := make([]*datastore.OrganizationDatastore, len(keys))
	for i := range entities {
		entities[i].Key = keys[i]
		result[i] = &entities[i]
	}
	return result, nil
}

// PutMulti saves multiple datastore.OrganizationDatastore entities to Datastore.
// Returns the keys used to store the entities.
func (d *OrganizationDatastoreDAL) PutMulti(ctx context.Context, client *dslib.Client, objs []*datastore.OrganizationDatastore) ([]*dslib.Key, error) {
	if len(objs) == 0 {
		return []*dslib.Key{}, nil
	}

	// Call WillPut hook for each entity
	if d.WillPut != nil {
		for _, obj := range objs {
			if err := d.WillPut(ctx, obj); err != nil {
				return nil, err
			}
		}
	}

	// Build keys for each entity
	keys := make([]*dslib.Key, len(objs))
	for i, obj := range objs {
		if obj.Key != nil {
			keys[i] = obj.Key
			if d.Namespace != "" {
				keys[i].Namespace = d.Namespace
			}
		} else if obj.Id != "" {
			keys[i] = d.newKey(obj.Id)
		} else {
			keys[i] = d.newIncompleteKey()
		}
	}

	// Put all entities
	resultKeys, err := client.PutMulti(ctx, keys, objs)
	if err != nil {
		return nil, err
	}

	// Update entity keys
	for i, key := range resultKeys {
		objs[i].Key = key
	}

	return resultKeys, nil
}

// DeleteMulti removes multiple datastore.OrganizationDatastore entities by keys.
func (d *OrganizationDatastoreDAL) DeleteMulti(ctx context.Context, client *dslib.Client, keys []*dslib.Key) error {
	if len(keys) == 0 {
		return nil
	}
	return client.DeleteMulti(ctx, keys)
}

// Query retrieves datastore.OrganizationDatastore entities matching the query.
// The caller should create a query using dslib.NewQuery(dal.getKind()).
func (d *OrganizationDatastoreDAL) Query(ctx context.Context, client *dslib.Client, q *dslib.Query) ([]*datastore.OrganizationDatastore, error) {
	var entities []*datastore.OrganizationDatastore
	keys, err := client.GetAll(ctx, q, &entities)
	if err != nil {
		return nil, err
	}

	// Set keys on entities
	for i, key := range keys {
		entities[i].Key = key
	}

	return entities, nil
}

// Count returns the number of entities matching the query.
func (d *OrganizationDatastoreDAL) Count(ctx context.Context, client *dslib.Client, q *dslib.Query) (int, error) {
	return client.Count(ctx, q)
}

// GetByID retrieves a datastore.OrganizationDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
// Returns (nil, nil) if the entity is not found.
func (d *OrganizationDatastoreDAL) GetByID(ctx context.Context, client *dslib.Client, id string) (*datastore.OrganizationDatastore, error) {
	key := d.newKey(id)
	return d.Get(ctx, client, key)
}

// DeleteByID removes a datastore.OrganizationDatastore entity by ID.
// This is a convenience method that creates a key from the ID.
func (d *OrganizationDatastoreDAL) DeleteByID(ctx context.Context, client *dslib.Client, id string) error {
	key := d.newKey(id)
	return d.Delete(ctx, client, key)
}

// GetMultiByIDs retrieves multiple datastore.OrganizationDatastore entities by IDs.
// This is a convenience method that creates keys from the IDs.
// Returns entities in the same order as the IDs. Missing entities are nil in the result slice.
func (d *OrganizationDatastoreDAL) GetMultiByIDs(ctx context.Context, client *dslib.Client, ids []string) ([]*datastore.OrganizationDatastore, error) {
	if len(ids) == 0 {
		return []*datastore.OrganizationDatastore{}, nil
	}

	keys := make([]*dslib.Key, len(ids))
	for i, id := range ids {
		keys[i] = d.newKey(id)
	}

	return d.GetMulti(ctx, client, keys)
}
