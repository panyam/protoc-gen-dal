// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package gorm

import (
	"context"
	"errors"

	"gorm.io/gorm"
)

// WorldGORMDAL provides database access helper methods for WorldGORM.
type WorldGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *WorldGORM) error
}

// Save creates or updates a WorldGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *WorldGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *WorldGORM) error {
	// Validate primary key(s)
	if obj.Id == "" {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a WorldGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *WorldGORMDAL) Get(ctx context.Context, db *gorm.DB, id string) (*WorldGORM, error) {
	var out WorldGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a WorldGORM record by primary key.
func (d *WorldGORMDAL) Delete(ctx context.Context, db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&WorldGORM{}).Error
}

// List retrieves multiple WorldGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *WorldGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*WorldGORM, error) {
	var out []*WorldGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple WorldGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *WorldGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []string) ([]*WorldGORM, error) {
	if len(ids) == 0 {
		return []*WorldGORM{}, nil
	}

	var out []*WorldGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// WorldDataGORMDAL provides database access helper methods for WorldDataGORM.
type WorldDataGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *WorldDataGORM) error
}

// Save creates or updates a WorldDataGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *WorldDataGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *WorldDataGORM) error {
	// Validate primary key(s)
	if obj.WorldId == "" {
		return errors.New("primary key 'WorldId' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a WorldDataGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *WorldDataGORMDAL) Get(ctx context.Context, db *gorm.DB, worldId string) (*WorldDataGORM, error) {
	var out WorldDataGORM
	err := db.First(&out, "world_id = ?", worldId).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a WorldDataGORM record by primary key.
func (d *WorldDataGORMDAL) Delete(ctx context.Context, db *gorm.DB, worldId string) error {
	return db.Where("world_id = ?", worldId).Delete(&WorldDataGORM{}).Error
}

// List retrieves multiple WorldDataGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *WorldDataGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*WorldDataGORM, error) {
	var out []*WorldDataGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple WorldDataGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *WorldDataGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, worldIds []string) ([]*WorldDataGORM, error) {
	if len(worldIds) == 0 {
		return []*WorldDataGORM{}, nil
	}

	var out []*WorldDataGORM
	err := db.Where("world_id IN ?", worldIds).Find(&out).Error
	return out, err
}

// GameGORMDAL provides database access helper methods for GameGORM.
type GameGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *GameGORM) error
}

// Save creates or updates a GameGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *GameGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *GameGORM) error {
	// Validate primary key(s)
	if obj.Id == "" {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a GameGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameGORMDAL) Get(ctx context.Context, db *gorm.DB, id string) (*GameGORM, error) {
	var out GameGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a GameGORM record by primary key.
func (d *GameGORMDAL) Delete(ctx context.Context, db *gorm.DB, id string) error {
	return db.Where("id = ?", id).Delete(&GameGORM{}).Error
}

// List retrieves multiple GameGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*GameGORM, error) {
	var out []*GameGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple GameGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []string) ([]*GameGORM, error) {
	if len(ids) == 0 {
		return []*GameGORM{}, nil
	}

	var out []*GameGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// GameStateGORMDAL provides database access helper methods for GameStateGORM.
type GameStateGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *GameStateGORM) error
}

// Save creates or updates a GameStateGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *GameStateGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *GameStateGORM) error {
	// Validate primary key(s)
	if obj.GameId == "" {
		return errors.New("primary key 'GameId' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a GameStateGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameStateGORMDAL) Get(ctx context.Context, db *gorm.DB, gameId string) (*GameStateGORM, error) {
	var out GameStateGORM
	err := db.First(&out, "game_id = ?", gameId).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a GameStateGORM record by primary key.
func (d *GameStateGORMDAL) Delete(ctx context.Context, db *gorm.DB, gameId string) error {
	return db.Where("game_id = ?", gameId).Delete(&GameStateGORM{}).Error
}

// List retrieves multiple GameStateGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameStateGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*GameStateGORM, error) {
	var out []*GameStateGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple GameStateGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameStateGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, gameIds []string) ([]*GameStateGORM, error) {
	if len(gameIds) == 0 {
		return []*GameStateGORM{}, nil
	}

	var out []*GameStateGORM
	err := db.Where("game_id IN ?", gameIds).Find(&out).Error
	return out, err
}

// GameMoveKey represents the composite primary key for GameMoveGORM
type GameMoveKey struct {
	GameId      string
	GroupNumber string
	MoveNumber  int32
}

// GameMoveGORMDAL provides database access helper methods for GameMoveGORM.
type GameMoveGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *GameMoveGORM) error
}

// Save creates or updates a GameMoveGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *GameMoveGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *GameMoveGORM) error {
	// Validate primary key(s)
	if obj.GameId == "" {
		return errors.New("primary key 'GameId' cannot be empty")
	}
	if obj.GroupNumber == "" {
		return errors.New("primary key 'GroupNumber' cannot be empty")
	}
	if obj.MoveNumber == 0 {
		return errors.New("primary key 'MoveNumber' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a GameMoveGORM record by primary keys.
// Returns (nil, nil) if the record is not found (not an error).
func (d *GameMoveGORMDAL) Get(ctx context.Context, db *gorm.DB, gameId string, groupNumber string, moveNumber int32) (*GameMoveGORM, error) {
	var out GameMoveGORM
	err := db.First(&out, "game_id = ? AND group_number = ? AND move_number = ?", gameId, groupNumber, moveNumber).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a GameMoveGORM record by primary keys.
func (d *GameMoveGORMDAL) Delete(ctx context.Context, db *gorm.DB, gameId string, groupNumber string, moveNumber int32) error {
	return db.Where("game_id = ? AND group_number = ? AND move_number = ?", gameId, groupNumber, moveNumber).Delete(&GameMoveGORM{}).Error
}

// List retrieves multiple GameMoveGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *GameMoveGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*GameMoveGORM, error) {
	var out []*GameMoveGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple GameMoveGORM records by primary keys.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *GameMoveGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, keys []GameMoveKey) ([]*GameMoveGORM, error) {
	if len(keys) == 0 {
		return []*GameMoveGORM{}, nil
	}

	// Build OR query for each key combination
	query := db.Where("1 = 0") // Start with false condition
	for _, key := range keys {
		query = query.Or("game_id = ? AND group_number = ? AND move_number = ?", key.GameId, key.GroupNumber, key.MoveNumber)
	}

	var out []*GameMoveGORM
	err := query.Find(&out).Error
	return out, err
}
