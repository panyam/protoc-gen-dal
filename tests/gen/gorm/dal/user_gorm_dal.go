// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package dal

import (
	"context"
	"errors"

	gorm "github.com/panyam/protoc-gen-dal/tests/gen/gorm"
	gormlib "gorm.io/gorm"
)

// UserGORMDAL provides database access helper methods for gorm.UserGORM.
type UserGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserGORM) error
}

// Save creates or updates a gorm.UserGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.UserGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserGORM, error) {
	var out gorm.UserGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserGORM record by primary key.
func (d *UserGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.UserGORM{}).Error
}

// List retrieves multiple gorm.UserGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserGORM, error) {
	var out []*gorm.UserGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserGORM, error) {
	if len(ids) == 0 {
		return []*gorm.UserGORM{}, nil
	}

	var out []*gorm.UserGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithPermissionsDAL provides database access helper methods for gorm.UserWithPermissions.
type UserWithPermissionsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithPermissions) error
}

// Save creates or updates a gorm.UserWithPermissions record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithPermissionsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithPermissions) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.UserWithPermissions record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithPermissionsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithPermissions, error) {
	var out gorm.UserWithPermissions
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithPermissions record by primary key.
func (d *UserWithPermissionsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.UserWithPermissions{}).Error
}

// List retrieves multiple gorm.UserWithPermissions records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithPermissionsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithPermissions, error) {
	var out []*gorm.UserWithPermissions
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithPermissions records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithPermissionsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithPermissions, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithPermissions{}, nil
	}

	var out []*gorm.UserWithPermissions
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithCustomTimestampsDAL provides database access helper methods for gorm.UserWithCustomTimestamps.
type UserWithCustomTimestampsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithCustomTimestamps) error
}

// Save creates or updates a gorm.UserWithCustomTimestamps record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithCustomTimestampsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithCustomTimestamps) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.UserWithCustomTimestamps record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithCustomTimestampsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithCustomTimestamps, error) {
	var out gorm.UserWithCustomTimestamps
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithCustomTimestamps record by primary key.
func (d *UserWithCustomTimestampsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.UserWithCustomTimestamps{}).Error
}

// List retrieves multiple gorm.UserWithCustomTimestamps records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithCustomTimestampsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithCustomTimestamps, error) {
	var out []*gorm.UserWithCustomTimestamps
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithCustomTimestamps records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithCustomTimestampsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithCustomTimestamps, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithCustomTimestamps{}, nil
	}

	var out []*gorm.UserWithCustomTimestamps
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithIndexesDAL provides database access helper methods for gorm.UserWithIndexes.
type UserWithIndexesDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithIndexes) error
}

// Save creates or updates a gorm.UserWithIndexes record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithIndexesDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithIndexes) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.UserWithIndexes record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithIndexesDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithIndexes, error) {
	var out gorm.UserWithIndexes
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithIndexes record by primary key.
func (d *UserWithIndexesDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.UserWithIndexes{}).Error
}

// List retrieves multiple gorm.UserWithIndexes records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithIndexesDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithIndexes, error) {
	var out []*gorm.UserWithIndexes
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithIndexes records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithIndexesDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithIndexes, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithIndexes{}, nil
	}

	var out []*gorm.UserWithIndexes
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithDefaultsDAL provides database access helper methods for gorm.UserWithDefaults.
type UserWithDefaultsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithDefaults) error
}

// Save creates or updates a gorm.UserWithDefaults record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithDefaultsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithDefaults) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.UserWithDefaults record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithDefaultsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithDefaults, error) {
	var out gorm.UserWithDefaults
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithDefaults record by primary key.
func (d *UserWithDefaultsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.UserWithDefaults{}).Error
}

// List retrieves multiple gorm.UserWithDefaults records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithDefaultsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithDefaults, error) {
	var out []*gorm.UserWithDefaults
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithDefaults records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithDefaultsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithDefaults, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithDefaults{}, nil
	}

	var out []*gorm.UserWithDefaults
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// BlogGORMDAL provides database access helper methods for gorm.BlogGORM.
type BlogGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.BlogGORM) error
}

// Save creates or updates a gorm.BlogGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *BlogGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.BlogGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.BlogGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *BlogGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.BlogGORM, error) {
	var out gorm.BlogGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.BlogGORM record by primary key.
func (d *BlogGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.BlogGORM{}).Error
}

// List retrieves multiple gorm.BlogGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *BlogGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.BlogGORM, error) {
	var out []*gorm.BlogGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.BlogGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *BlogGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.BlogGORM, error) {
	if len(ids) == 0 {
		return []*gorm.BlogGORM{}, nil
	}

	var out []*gorm.BlogGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// ProductGORMDAL provides database access helper methods for gorm.ProductGORM.
type ProductGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.ProductGORM) error
}

// Save creates or updates a gorm.ProductGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *ProductGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.ProductGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.ProductGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *ProductGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.ProductGORM, error) {
	var out gorm.ProductGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.ProductGORM record by primary key.
func (d *ProductGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.ProductGORM{}).Error
}

// List retrieves multiple gorm.ProductGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *ProductGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.ProductGORM, error) {
	var out []*gorm.ProductGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.ProductGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *ProductGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.ProductGORM, error) {
	if len(ids) == 0 {
		return []*gorm.ProductGORM{}, nil
	}

	var out []*gorm.ProductGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// LibraryGORMDAL provides database access helper methods for gorm.LibraryGORM.
type LibraryGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.LibraryGORM) error
}

// Save creates or updates a gorm.LibraryGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *LibraryGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.LibraryGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.LibraryGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *LibraryGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.LibraryGORM, error) {
	var out gorm.LibraryGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.LibraryGORM record by primary key.
func (d *LibraryGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.LibraryGORM{}).Error
}

// List retrieves multiple gorm.LibraryGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *LibraryGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.LibraryGORM, error) {
	var out []*gorm.LibraryGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.LibraryGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *LibraryGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.LibraryGORM, error) {
	if len(ids) == 0 {
		return []*gorm.LibraryGORM{}, nil
	}

	var out []*gorm.LibraryGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// OrganizationGORMDAL provides database access helper methods for gorm.OrganizationGORM.
type OrganizationGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.OrganizationGORM) error
}

// Save creates or updates a gorm.OrganizationGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *OrganizationGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.OrganizationGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.OrganizationGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *OrganizationGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.OrganizationGORM, error) {
	var out gorm.OrganizationGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.OrganizationGORM record by primary key.
func (d *OrganizationGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.OrganizationGORM{}).Error
}

// List retrieves multiple gorm.OrganizationGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *OrganizationGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.OrganizationGORM, error) {
	var out []*gorm.OrganizationGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.OrganizationGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *OrganizationGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.OrganizationGORM, error) {
	if len(ids) == 0 {
		return []*gorm.OrganizationGORM{}, nil
	}

	var out []*gorm.OrganizationGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}
