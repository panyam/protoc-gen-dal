// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package dal

import (
	"context"
	"errors"

	gorm "github.com/panyam/protoc-gen-dal/tests/gen/gorm"
	gormlib "gorm.io/gorm"
)

// UserGORMDAL provides database access helper methods for gorm.UserGORM.
type UserGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserGORM) error
}

// NewUserGORMDAL creates a new UserGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewUserGORMDAL(tableName string) *UserGORMDAL {
	return &UserGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *UserGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.UserGORM record.
// Returns an error if the record already exists.
func (d *UserGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.UserGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.UserGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.UserGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.UserGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.UserGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.UserGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserGORM, error) {
	var out gorm.UserGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserGORM record by primary key.
func (d *UserGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.UserGORM{}).Error
}

// List retrieves multiple gorm.UserGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserGORM, error) {
	var out []*gorm.UserGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserGORM, error) {
	if len(ids) == 0 {
		return []*gorm.UserGORM{}, nil
	}

	var out []*gorm.UserGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithPermissionsDAL provides database access helper methods for gorm.UserWithPermissions.
type UserWithPermissionsDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithPermissions) error
}

// NewUserWithPermissionsDAL creates a new UserWithPermissionsDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewUserWithPermissionsDAL(tableName string) *UserWithPermissionsDAL {
	return &UserWithPermissionsDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *UserWithPermissionsDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.UserWithPermissions record.
// Returns an error if the record already exists.
func (d *UserWithPermissionsDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithPermissions) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.UserWithPermissions record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithPermissionsDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithPermissions) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.UserWithPermissions record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithPermissionsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithPermissions) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.UserWithPermissions
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.UserWithPermissions record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithPermissionsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithPermissions, error) {
	var out gorm.UserWithPermissions
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithPermissions record by primary key.
func (d *UserWithPermissionsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.UserWithPermissions{}).Error
}

// List retrieves multiple gorm.UserWithPermissions records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithPermissionsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithPermissions, error) {
	var out []*gorm.UserWithPermissions
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithPermissions records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithPermissionsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithPermissions, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithPermissions{}, nil
	}

	var out []*gorm.UserWithPermissions
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithCustomTimestampsDAL provides database access helper methods for gorm.UserWithCustomTimestamps.
type UserWithCustomTimestampsDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithCustomTimestamps) error
}

// NewUserWithCustomTimestampsDAL creates a new UserWithCustomTimestampsDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewUserWithCustomTimestampsDAL(tableName string) *UserWithCustomTimestampsDAL {
	return &UserWithCustomTimestampsDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *UserWithCustomTimestampsDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.UserWithCustomTimestamps record.
// Returns an error if the record already exists.
func (d *UserWithCustomTimestampsDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithCustomTimestamps) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.UserWithCustomTimestamps record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithCustomTimestampsDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithCustomTimestamps) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.UserWithCustomTimestamps record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithCustomTimestampsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithCustomTimestamps) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.UserWithCustomTimestamps
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.UserWithCustomTimestamps record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithCustomTimestampsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithCustomTimestamps, error) {
	var out gorm.UserWithCustomTimestamps
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithCustomTimestamps record by primary key.
func (d *UserWithCustomTimestampsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.UserWithCustomTimestamps{}).Error
}

// List retrieves multiple gorm.UserWithCustomTimestamps records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithCustomTimestampsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithCustomTimestamps, error) {
	var out []*gorm.UserWithCustomTimestamps
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithCustomTimestamps records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithCustomTimestampsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithCustomTimestamps, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithCustomTimestamps{}, nil
	}

	var out []*gorm.UserWithCustomTimestamps
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithIndexesDAL provides database access helper methods for gorm.UserWithIndexes.
type UserWithIndexesDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithIndexes) error
}

// NewUserWithIndexesDAL creates a new UserWithIndexesDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewUserWithIndexesDAL(tableName string) *UserWithIndexesDAL {
	return &UserWithIndexesDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *UserWithIndexesDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.UserWithIndexes record.
// Returns an error if the record already exists.
func (d *UserWithIndexesDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithIndexes) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.UserWithIndexes record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithIndexesDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithIndexes) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.UserWithIndexes record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithIndexesDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithIndexes) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.UserWithIndexes
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.UserWithIndexes record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithIndexesDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithIndexes, error) {
	var out gorm.UserWithIndexes
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithIndexes record by primary key.
func (d *UserWithIndexesDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.UserWithIndexes{}).Error
}

// List retrieves multiple gorm.UserWithIndexes records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithIndexesDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithIndexes, error) {
	var out []*gorm.UserWithIndexes
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithIndexes records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithIndexesDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithIndexes, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithIndexes{}, nil
	}

	var out []*gorm.UserWithIndexes
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithDefaultsDAL provides database access helper methods for gorm.UserWithDefaults.
type UserWithDefaultsDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.UserWithDefaults) error
}

// NewUserWithDefaultsDAL creates a new UserWithDefaultsDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewUserWithDefaultsDAL(tableName string) *UserWithDefaultsDAL {
	return &UserWithDefaultsDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *UserWithDefaultsDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.UserWithDefaults record.
// Returns an error if the record already exists.
func (d *UserWithDefaultsDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithDefaults) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.UserWithDefaults record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithDefaultsDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithDefaults) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.UserWithDefaults record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *UserWithDefaultsDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.UserWithDefaults) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.UserWithDefaults
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.UserWithDefaults record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithDefaultsDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.UserWithDefaults, error) {
	var out gorm.UserWithDefaults
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.UserWithDefaults record by primary key.
func (d *UserWithDefaultsDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.UserWithDefaults{}).Error
}

// List retrieves multiple gorm.UserWithDefaults records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithDefaultsDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.UserWithDefaults, error) {
	var out []*gorm.UserWithDefaults
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.UserWithDefaults records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithDefaultsDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.UserWithDefaults, error) {
	if len(ids) == 0 {
		return []*gorm.UserWithDefaults{}, nil
	}

	var out []*gorm.UserWithDefaults
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// BlogGORMDAL provides database access helper methods for gorm.BlogGORM.
type BlogGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.BlogGORM) error
}

// NewBlogGORMDAL creates a new BlogGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewBlogGORMDAL(tableName string) *BlogGORMDAL {
	return &BlogGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *BlogGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.BlogGORM record.
// Returns an error if the record already exists.
func (d *BlogGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.BlogGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.BlogGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *BlogGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.BlogGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.BlogGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *BlogGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.BlogGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.BlogGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.BlogGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *BlogGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.BlogGORM, error) {
	var out gorm.BlogGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.BlogGORM record by primary key.
func (d *BlogGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.BlogGORM{}).Error
}

// List retrieves multiple gorm.BlogGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *BlogGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.BlogGORM, error) {
	var out []*gorm.BlogGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.BlogGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *BlogGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.BlogGORM, error) {
	if len(ids) == 0 {
		return []*gorm.BlogGORM{}, nil
	}

	var out []*gorm.BlogGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// ProductGORMDAL provides database access helper methods for gorm.ProductGORM.
type ProductGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.ProductGORM) error
}

// NewProductGORMDAL creates a new ProductGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewProductGORMDAL(tableName string) *ProductGORMDAL {
	return &ProductGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *ProductGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.ProductGORM record.
// Returns an error if the record already exists.
func (d *ProductGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.ProductGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.ProductGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *ProductGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.ProductGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.ProductGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *ProductGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.ProductGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.ProductGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.ProductGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *ProductGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.ProductGORM, error) {
	var out gorm.ProductGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.ProductGORM record by primary key.
func (d *ProductGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.ProductGORM{}).Error
}

// List retrieves multiple gorm.ProductGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *ProductGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.ProductGORM, error) {
	var out []*gorm.ProductGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.ProductGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *ProductGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.ProductGORM, error) {
	if len(ids) == 0 {
		return []*gorm.ProductGORM{}, nil
	}

	var out []*gorm.ProductGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// LibraryGORMDAL provides database access helper methods for gorm.LibraryGORM.
type LibraryGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.LibraryGORM) error
}

// NewLibraryGORMDAL creates a new LibraryGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewLibraryGORMDAL(tableName string) *LibraryGORMDAL {
	return &LibraryGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *LibraryGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.LibraryGORM record.
// Returns an error if the record already exists.
func (d *LibraryGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.LibraryGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.LibraryGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *LibraryGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.LibraryGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.LibraryGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *LibraryGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.LibraryGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.LibraryGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.LibraryGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *LibraryGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.LibraryGORM, error) {
	var out gorm.LibraryGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.LibraryGORM record by primary key.
func (d *LibraryGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.LibraryGORM{}).Error
}

// List retrieves multiple gorm.LibraryGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *LibraryGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.LibraryGORM, error) {
	var out []*gorm.LibraryGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.LibraryGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *LibraryGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.LibraryGORM, error) {
	if len(ids) == 0 {
		return []*gorm.LibraryGORM{}, nil
	}

	var out []*gorm.LibraryGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// OrganizationGORMDAL provides database access helper methods for gorm.OrganizationGORM.
type OrganizationGORMDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.OrganizationGORM) error
}

// NewOrganizationGORMDAL creates a new OrganizationGORMDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewOrganizationGORMDAL(tableName string) *OrganizationGORMDAL {
	return &OrganizationGORMDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *OrganizationGORMDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.OrganizationGORM record.
// Returns an error if the record already exists.
func (d *OrganizationGORMDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.OrganizationGORM) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.OrganizationGORM record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *OrganizationGORMDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.OrganizationGORM) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.OrganizationGORM record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *OrganizationGORMDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.OrganizationGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.OrganizationGORM
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.OrganizationGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *OrganizationGORMDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.OrganizationGORM, error) {
	var out gorm.OrganizationGORM
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.OrganizationGORM record by primary key.
func (d *OrganizationGORMDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.OrganizationGORM{}).Error
}

// List retrieves multiple gorm.OrganizationGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *OrganizationGORMDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.OrganizationGORM, error) {
	var out []*gorm.OrganizationGORM
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.OrganizationGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *OrganizationGORMDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.OrganizationGORM, error) {
	if len(ids) == 0 {
		return []*gorm.OrganizationGORM{}, nil
	}

	var out []*gorm.OrganizationGORM
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}
