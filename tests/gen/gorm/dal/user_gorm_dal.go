// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package gorm

import (
	"context"
	"errors"

	"gorm.io/gorm"
)

// UserGORMDAL provides database access helper methods for UserGORM.
type UserGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *UserGORM) error
}

// Save creates or updates a UserGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *UserGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a UserGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserGORMDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*UserGORM, error) {
	var out UserGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a UserGORM record by primary key.
func (d *UserGORMDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&UserGORM{}).Error
}

// List retrieves multiple UserGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*UserGORM, error) {
	var out []*UserGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple UserGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*UserGORM, error) {
	if len(ids) == 0 {
		return []*UserGORM{}, nil
	}

	var out []*UserGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithPermissionsDAL provides database access helper methods for UserWithPermissions.
type UserWithPermissionsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *UserWithPermissions) error
}

// Save creates or updates a UserWithPermissions record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithPermissionsDAL) Save(ctx context.Context, db *gorm.DB, obj *UserWithPermissions) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a UserWithPermissions record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithPermissionsDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*UserWithPermissions, error) {
	var out UserWithPermissions
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a UserWithPermissions record by primary key.
func (d *UserWithPermissionsDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&UserWithPermissions{}).Error
}

// List retrieves multiple UserWithPermissions records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithPermissionsDAL) List(ctx context.Context, query *gorm.DB) ([]*UserWithPermissions, error) {
	var out []*UserWithPermissions
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple UserWithPermissions records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithPermissionsDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*UserWithPermissions, error) {
	if len(ids) == 0 {
		return []*UserWithPermissions{}, nil
	}

	var out []*UserWithPermissions
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithCustomTimestampsDAL provides database access helper methods for UserWithCustomTimestamps.
type UserWithCustomTimestampsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *UserWithCustomTimestamps) error
}

// Save creates or updates a UserWithCustomTimestamps record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithCustomTimestampsDAL) Save(ctx context.Context, db *gorm.DB, obj *UserWithCustomTimestamps) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a UserWithCustomTimestamps record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithCustomTimestampsDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*UserWithCustomTimestamps, error) {
	var out UserWithCustomTimestamps
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a UserWithCustomTimestamps record by primary key.
func (d *UserWithCustomTimestampsDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&UserWithCustomTimestamps{}).Error
}

// List retrieves multiple UserWithCustomTimestamps records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithCustomTimestampsDAL) List(ctx context.Context, query *gorm.DB) ([]*UserWithCustomTimestamps, error) {
	var out []*UserWithCustomTimestamps
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple UserWithCustomTimestamps records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithCustomTimestampsDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*UserWithCustomTimestamps, error) {
	if len(ids) == 0 {
		return []*UserWithCustomTimestamps{}, nil
	}

	var out []*UserWithCustomTimestamps
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithIndexesDAL provides database access helper methods for UserWithIndexes.
type UserWithIndexesDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *UserWithIndexes) error
}

// Save creates or updates a UserWithIndexes record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithIndexesDAL) Save(ctx context.Context, db *gorm.DB, obj *UserWithIndexes) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a UserWithIndexes record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithIndexesDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*UserWithIndexes, error) {
	var out UserWithIndexes
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a UserWithIndexes record by primary key.
func (d *UserWithIndexesDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&UserWithIndexes{}).Error
}

// List retrieves multiple UserWithIndexes records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithIndexesDAL) List(ctx context.Context, query *gorm.DB) ([]*UserWithIndexes, error) {
	var out []*UserWithIndexes
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple UserWithIndexes records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithIndexesDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*UserWithIndexes, error) {
	if len(ids) == 0 {
		return []*UserWithIndexes{}, nil
	}

	var out []*UserWithIndexes
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// UserWithDefaultsDAL provides database access helper methods for UserWithDefaults.
type UserWithDefaultsDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *UserWithDefaults) error
}

// Save creates or updates a UserWithDefaults record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *UserWithDefaultsDAL) Save(ctx context.Context, db *gorm.DB, obj *UserWithDefaults) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a UserWithDefaults record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *UserWithDefaultsDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*UserWithDefaults, error) {
	var out UserWithDefaults
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a UserWithDefaults record by primary key.
func (d *UserWithDefaultsDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&UserWithDefaults{}).Error
}

// List retrieves multiple UserWithDefaults records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *UserWithDefaultsDAL) List(ctx context.Context, query *gorm.DB) ([]*UserWithDefaults, error) {
	var out []*UserWithDefaults
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple UserWithDefaults records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *UserWithDefaultsDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*UserWithDefaults, error) {
	if len(ids) == 0 {
		return []*UserWithDefaults{}, nil
	}

	var out []*UserWithDefaults
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// BlogGORMDAL provides database access helper methods for BlogGORM.
type BlogGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *BlogGORM) error
}

// Save creates or updates a BlogGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *BlogGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *BlogGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a BlogGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *BlogGORMDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*BlogGORM, error) {
	var out BlogGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a BlogGORM record by primary key.
func (d *BlogGORMDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&BlogGORM{}).Error
}

// List retrieves multiple BlogGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *BlogGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*BlogGORM, error) {
	var out []*BlogGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple BlogGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *BlogGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*BlogGORM, error) {
	if len(ids) == 0 {
		return []*BlogGORM{}, nil
	}

	var out []*BlogGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// ProductGORMDAL provides database access helper methods for ProductGORM.
type ProductGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *ProductGORM) error
}

// Save creates or updates a ProductGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *ProductGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *ProductGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a ProductGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *ProductGORMDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*ProductGORM, error) {
	var out ProductGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a ProductGORM record by primary key.
func (d *ProductGORMDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&ProductGORM{}).Error
}

// List retrieves multiple ProductGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *ProductGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*ProductGORM, error) {
	var out []*ProductGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple ProductGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *ProductGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*ProductGORM, error) {
	if len(ids) == 0 {
		return []*ProductGORM{}, nil
	}

	var out []*ProductGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// LibraryGORMDAL provides database access helper methods for LibraryGORM.
type LibraryGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *LibraryGORM) error
}

// Save creates or updates a LibraryGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *LibraryGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *LibraryGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a LibraryGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *LibraryGORMDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*LibraryGORM, error) {
	var out LibraryGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a LibraryGORM record by primary key.
func (d *LibraryGORMDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&LibraryGORM{}).Error
}

// List retrieves multiple LibraryGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *LibraryGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*LibraryGORM, error) {
	var out []*LibraryGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple LibraryGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *LibraryGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*LibraryGORM, error) {
	if len(ids) == 0 {
		return []*LibraryGORM{}, nil
	}

	var out []*LibraryGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// OrganizationGORMDAL provides database access helper methods for OrganizationGORM.
type OrganizationGORMDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *OrganizationGORM) error
}

// Save creates or updates a OrganizationGORM record.
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
func (d *OrganizationGORMDAL) Save(ctx context.Context, db *gorm.DB, obj *OrganizationGORM) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a OrganizationGORM record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *OrganizationGORMDAL) Get(ctx context.Context, db *gorm.DB, id uint32) (*OrganizationGORM, error) {
	var out OrganizationGORM
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a OrganizationGORM record by primary key.
func (d *OrganizationGORMDAL) Delete(ctx context.Context, db *gorm.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&OrganizationGORM{}).Error
}

// List retrieves multiple OrganizationGORM records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *OrganizationGORMDAL) List(ctx context.Context, query *gorm.DB) ([]*OrganizationGORM, error) {
	var out []*OrganizationGORM
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple OrganizationGORM records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *OrganizationGORMDAL) BatchGet(ctx context.Context, db *gorm.DB, ids []uint32) ([]*OrganizationGORM, error) {
	if len(ids) == 0 {
		return []*OrganizationGORM{}, nil
	}

	var out []*OrganizationGORM
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}
