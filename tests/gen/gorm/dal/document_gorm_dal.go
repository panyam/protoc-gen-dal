// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package dal

import (
	"context"
	"errors"

	gorm "github.com/panyam/protoc-gen-dal/tests/gen/gorm"
	gormlib "gorm.io/gorm"
)

// DocumentGormPartialDAL provides database access helper methods for gorm.DocumentGormPartial.
type DocumentGormPartialDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.DocumentGormPartial) error
}

// NewDocumentGormPartialDAL creates a new DocumentGormPartialDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewDocumentGormPartialDAL(tableName string) *DocumentGormPartialDAL {
	return &DocumentGormPartialDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *DocumentGormPartialDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.DocumentGormPartial record.
// Returns an error if the record already exists.
func (d *DocumentGormPartialDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.DocumentGormPartial record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormPartialDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.DocumentGormPartial record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormPartialDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.DocumentGormPartial
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.DocumentGormPartial record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *DocumentGormPartialDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.DocumentGormPartial, error) {
	var out gorm.DocumentGormPartial
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.DocumentGormPartial record by primary key.
func (d *DocumentGormPartialDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.DocumentGormPartial{}).Error
}

// List retrieves multiple gorm.DocumentGormPartial records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *DocumentGormPartialDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.DocumentGormPartial, error) {
	var out []*gorm.DocumentGormPartial
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.DocumentGormPartial records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *DocumentGormPartialDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.DocumentGormPartial, error) {
	if len(ids) == 0 {
		return []*gorm.DocumentGormPartial{}, nil
	}

	var out []*gorm.DocumentGormPartial
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// DocumentGormSkipDAL provides database access helper methods for gorm.DocumentGormSkip.
type DocumentGormSkipDAL struct {
	// TableName overrides the table for all operations.
	// If empty, uses the struct's TableName() method (if any) or GORM's default.
	TableName string

	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.DocumentGormSkip) error
}

// NewDocumentGormSkipDAL creates a new DocumentGormSkipDAL instance.
// If tableName is empty, operations will use the struct's TableName() method
// or GORM's default table naming convention.
func NewDocumentGormSkipDAL(tableName string) *DocumentGormSkipDAL {
	return &DocumentGormSkipDAL{TableName: tableName}
}

// db returns a *gorm.DB scoped to the correct table.
// If TableName is set, uses db.Table(); otherwise returns db unchanged
// to let GORM resolve the table name from the struct's TableName() method.
func (d *DocumentGormSkipDAL) db(db *gormlib.DB) *gormlib.DB {
	if d.TableName != "" {
		return db.Table(d.TableName)
	}
	return db
}

// Create creates a new gorm.DocumentGormSkip record.
// Returns an error if the record already exists.
func (d *DocumentGormSkipDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	return d.db(db).Create(obj).Error
}

// Update updates an existing gorm.DocumentGormSkip record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormSkipDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	result := d.db(db).Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.DocumentGormSkip record (upsert).
// If the record doesn't exist, it will call WillCreate hook before saving.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormSkipDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	// Check if record exists by trying to fetch it
	var existing gorm.DocumentGormSkip
	err := d.db(db).First(&existing, "id = ?", obj.Id).Error

	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			// Record doesn't exist - call WillCreate hook before saving
			if d.WillCreate != nil {
				if err := d.WillCreate(ctx, obj); err != nil {
					return err
				}
			}
		} else {
			// Other error
			return err
		}
	}

	// Save (create or update)
	return d.db(db).Save(obj).Error
}

// Get retrieves a gorm.DocumentGormSkip record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *DocumentGormSkipDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.DocumentGormSkip, error) {
	var out gorm.DocumentGormSkip
	err := d.db(db).First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.DocumentGormSkip record by primary key.
func (d *DocumentGormSkipDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return d.db(db).Where("id = ?", id).Delete(&gorm.DocumentGormSkip{}).Error
}

// List retrieves multiple gorm.DocumentGormSkip records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *DocumentGormSkipDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.DocumentGormSkip, error) {
	var out []*gorm.DocumentGormSkip
	err := d.db(query).Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.DocumentGormSkip records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *DocumentGormSkipDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.DocumentGormSkip, error) {
	if len(ids) == 0 {
		return []*gorm.DocumentGormSkip{}, nil
	}

	var out []*gorm.DocumentGormSkip
	err := d.db(db).Where("id IN ?", ids).Find(&out).Error
	return out, err
}
