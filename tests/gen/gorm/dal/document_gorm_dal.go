// Code generated by protoc-gen-dal-gorm. DO NOT EDIT.
package dal

import (
	"context"
	"errors"

	gorm "github.com/panyam/protoc-gen-dal/tests/gen/gorm"
	gormlib "gorm.io/gorm"
)

// DocumentGormPartialDAL provides database access helper methods for gorm.DocumentGormPartial.
type DocumentGormPartialDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.DocumentGormPartial) error
}

// Create creates a new gorm.DocumentGormPartial record.
// Returns an error if the record already exists.
func (d *DocumentGormPartialDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	return db.Create(obj).Error
}

// Update updates an existing gorm.DocumentGormPartial record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormPartialDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	result := db.Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.DocumentGormPartial record (upsert).
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormPartialDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormPartial) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.DocumentGormPartial record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *DocumentGormPartialDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.DocumentGormPartial, error) {
	var out gorm.DocumentGormPartial
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.DocumentGormPartial record by primary key.
func (d *DocumentGormPartialDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.DocumentGormPartial{}).Error
}

// List retrieves multiple gorm.DocumentGormPartial records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *DocumentGormPartialDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.DocumentGormPartial, error) {
	var out []*gorm.DocumentGormPartial
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.DocumentGormPartial records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *DocumentGormPartialDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.DocumentGormPartial, error) {
	if len(ids) == 0 {
		return []*gorm.DocumentGormPartial{}, nil
	}

	var out []*gorm.DocumentGormPartial
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}

// DocumentGormSkipDAL provides database access helper methods for gorm.DocumentGormSkip.
type DocumentGormSkipDAL struct {
	// WillCreate hook is called when Save detects the record doesn't exist and will create it.
	// Return an error to prevent creation.
	WillCreate func(context.Context, *gorm.DocumentGormSkip) error
}

// Create creates a new gorm.DocumentGormSkip record.
// Returns an error if the record already exists.
func (d *DocumentGormSkipDAL) Create(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	return db.Create(obj).Error
}

// Update updates an existing gorm.DocumentGormSkip record.
// Returns ErrRecordNotFound if the record doesn't exist.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Update(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormSkipDAL) Update(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	result := db.Updates(obj)
	if result.Error != nil {
		return result.Error
	}

	// Check if record was found and updated
	if result.RowsAffected == 0 {
		return gormlib.ErrRecordNotFound
	}

	return nil
}

// Save creates or updates a gorm.DocumentGormSkip record (upsert).
// If the record doesn't exist (RowsAffected == 0), it will call WillCreate hook and then create the record.
// For conditional updates (optimistic locking), pass a db with WHERE conditions:
//
//	dal.Save(ctx, db.Where("version = ?", oldVersion), obj)
func (d *DocumentGormSkipDAL) Save(ctx context.Context, db *gormlib.DB, obj *gorm.DocumentGormSkip) error {
	// Validate primary key(s)
	if obj.Id == 0 {
		return errors.New("primary key 'Id' cannot be empty")
	}

	result := db.Save(obj)
	if result.Error == nil && result.RowsAffected == 0 {
		// Record doesn't exist - about to create
		if d.WillCreate != nil {
			if err := d.WillCreate(ctx, obj); err != nil {
				return err
			}
		}
		return db.Create(obj).Error
	}
	return result.Error
}

// Get retrieves a gorm.DocumentGormSkip record by primary key.
// Returns (nil, nil) if the record is not found (not an error).
func (d *DocumentGormSkipDAL) Get(ctx context.Context, db *gormlib.DB, id uint32) (*gorm.DocumentGormSkip, error) {
	var out gorm.DocumentGormSkip
	err := db.First(&out, "id = ?", id).Error
	if err != nil {
		if errors.Is(err, gormlib.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return &out, nil
}

// Delete removes a gorm.DocumentGormSkip record by primary key.
func (d *DocumentGormSkipDAL) Delete(ctx context.Context, db *gormlib.DB, id uint32) error {
	return db.Where("id = ?", id).Delete(&gorm.DocumentGormSkip{}).Error
}

// List retrieves multiple gorm.DocumentGormSkip records using the provided query.
// The caller is responsible for adding filters, ordering, and pagination to the query.
func (d *DocumentGormSkipDAL) List(ctx context.Context, query *gormlib.DB) ([]*gorm.DocumentGormSkip, error) {
	var out []*gorm.DocumentGormSkip
	err := query.Find(&out).Error
	return out, err
}

// BatchGet retrieves multiple gorm.DocumentGormSkip records by primary key.
// Results are returned in the order provided by the database (not necessarily the input order).
func (d *DocumentGormSkipDAL) BatchGet(ctx context.Context, db *gormlib.DB, ids []uint32) ([]*gorm.DocumentGormSkip, error) {
	if len(ids) == 0 {
		return []*gorm.DocumentGormSkip{}, nil
	}

	var out []*gorm.DocumentGormSkip
	err := db.Where("id IN ?", ids).Find(&out).Error
	return out, err
}
